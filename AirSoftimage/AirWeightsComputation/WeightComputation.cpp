// WeightComputationPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Thu Dec 20 13:03:54 UTC+0100 2012 by Chus
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_customoperator.h>
#include <xsi_operatorcontext.h>
#include <xsi_ppglayout.h>
#include <xsi_ppgeventcontext.h>
#include <xsi_selection.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_primitive.h>
#include <xsi_kinematics.h>
#include <xsi_outputport.h>

#include <xsi_dataarray2D.h>

#include <xsi_argument.h>
#include <xsi_geometry.h>
#include <xsi_point.h>
#include <xsi_x3dobject.h>
#include <xsi_ppglayout.h>
#include <xsi_menu.h>
#include <xsi_portgroup.h>
#include <xsi_math.h>
#include <xsi_kinematicstate.h>
#include <xsi_selection.h>
#include <xsi_facet.h>
#include <xsi_string.h>
#include <xsi_project.h>

#include <xsi_scene.h>
#include <xsi_sceneitem.h>

//CHAINS & BONES
#include <xsi_chainbone.h>
#include <xsi_chainroot.h>
#include <xsi_envelope.h>

//MODEL
#include <xsi_model.h>
#include <xsi_null.h>
#include <xsi_group.h>

#include <xsi_dictionary.h>

#include <iostream>
#include <fstream>
#include <direct.h>

#include <DataStructures\Scene.h>
#include <DataStructures\InteriorDistancesData.h>
#include <render\gridRender.h>
#include "../AirIceNode/AirIceNode.h"
//#include "../../"

using namespace XSI;
using namespace MATH; 

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
	// Basic plugin data
	in_reg.PutAuthor(L"Chus Rodriguez Nieto");
	in_reg.PutName(L"Air Weights Computation Plugin");
	in_reg.PutEmail(L"jrodrigueznieto@gmail.com");
	in_reg.PutURL(L"http://www.immagery.com");
	in_reg.PutVersion(1,0);
	
	in_reg.RegisterOperator(L"WeightComputation");
	RegisterAirICENode( in_reg );

	RegisterAirWeightsContextualization( in_reg );
	// Si quisieramos usarlo como un commando -> ahora lo deshabilito.
	//in_reg.RegisterCommand(L"ApplyWeightComputation",L"ApplyWeightComputation");
	//RegistrationInsertionPoint - do not remove this line

	in_reg.RegisterMenu(siMenuTbDeformID,L"ApplyWeightComputation_Menu",false,false);

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK XSI::CStatus ApplyWeightComputation_Menu_Init( XSI::CRef& in_ref )
{
	Context ctxt = in_ref;
	Menu menu = ctxt.GetSource();

	// Use built-in filter so that menu is greyed out if selection isn't a geometry
	menu.PutFilter( siGeometryFilter ) ;

	MenuItem item;

	// Unlike the JScript version we have created a specific 
	// custom command for creating the C++ Splatter.
	// The results are almost the same.
	CStatus st = menu.AddCallbackItem( L"Air Weights (C++)", L"ApplyWeightComputation", item );

	return st ;
}



SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siInfoMsg);
	return CStatus::OK;
}

/*SICALLBACK ApplyWeightComputation_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"Create an instance of WeightComputation operator");
	oCmd.SetFlag(siNoLogging,false);

	// TODO: You may want to add some arguments to this command so that the operator
	// can be applied to objects without depending on their specific names.
	// Tip: the Collection ArgumentHandler is very useful
	return CStatus::OK;
}*/

// Initialization. 
SICALLBACK ApplyWeightComputation( CRef& in_ctxt )
{
	Application().LogMessage(L"Apply...",siInfoMsg);

	OperatorContext ctxt( in_ctxt );
	Application app ;

	Selection selection = app.GetSelection() ;

	// User should have selected object(s) to deform
	if ( selection.GetCount() == 0 )
		return CStatus::InvalidArgument ;

	//scene* snc = new scene();
	//ctxt.PutUserData( (CValue::siPtrType)snc ); 

	for ( LONG i = 0 ; i < selection.GetCount() ; i++ )
	{
		
		X3DObject oObject = (CRef) selection[i] ;
		CRefArray inputs(1) ;
		Application().LogMessage(L"Cargamos el modelo: " + oObject.GetName(), siInfoMsg);
		//inputs[0] = oObject.GetActivePrimitive() ;

		CRefArray cdef;
		inputs[0] = oObject.GetActivePrimitive() ;
		//XSI::Geometry inGeom(oObject.GetActivePrimitive().GetGeometry());
		//snc->models.push_back((object*)new Modelo(snc->getNewId()));
		
		//LoadSoftImageModel(inGeom, (Modelo*)snc->models.back());

		CValueArray aAddCustomOpArgs(3) ;
		aAddCustomOpArgs[0] = L"WeightComputation" ;
		aAddCustomOpArgs[1] = oObject.GetActivePrimitive() ; // Outputs
		aAddCustomOpArgs[2] = inputs ;  
		CValue retOp ;

		app.ExecuteCommand( L"AddCustomOp", aAddCustomOpArgs, retOp ) ;

		XSI::Null nulObj;
		Application().GetActiveSceneRoot().AddNull(L"centro_aux", nulObj);

		CValueArray inPars(3);
		inPars[0] = oObject.GetName() + L";" + nulObj.GetName();
		inPars[1] = NULL;
		inPars[2] = 2;

		app.ExecuteCommand( L"ApplyFlexEnv", inPars, retOp);
		//ApplyFlexEnv("Mesh;COG,Spin01,spin02,neck001,neck002,neck003,Head,RF_leg_omoplato,RF_leg_up,RF_leg_knee,RF_leg_ankle,RF_leg_feet,LF_leg_omoplato,LF_leg_up,LF_leg_knee,LF_leg_ankle,LF_leg_feet,Hip,RR_leg001,RR_leg002,RR_leg003,RR_leg004,LR_leg001,LR_leg002,LR_leg003,LR_leg004", null, 2);

	}

	Application().LogMessage(L"Apply fin...",siInfoMsg);

	return CStatus::OK;
}

SICALLBACK WeightComputation_Define( CRef& in_ctxt )
{
	Application().LogMessage(L"Define...",siInfoMsg);

	Context ctxt( in_ctxt );
	CustomOperator oCustomOperator;

	Parameter oParam;
	CRef oPDef;
	
	Factory oFactory = Application().GetFactory();
	
	oCustomOperator = ctxt.GetSource();
	oPDef = oFactory.CreateParamDef(L"weight_map", CValue::siArray, CValue());
	oCustomOperator.AddParameter(oPDef,oParam);
	
	oPDef = oFactory.CreateParamDef(L"embeddingName", CValue::siString, L"C:\\DATA\\phd_dev\\Data\\models\\ternera_scene.txt");
	oCustomOperator.AddParameter(oPDef,oParam);

	//oPDef = oFactory.CreateParamDef(L"rig_anim_button",CValue::siBool, false);
	//oCustomOperator.AddParameter(oPDef,oParam);

	oPDef = oFactory.CreateParamDef(L"air_data",CValue::siPtr, NULL);
	oCustomOperator.AddParameter(oPDef,oParam);

	oPDef = oFactory.CreateParamDef(L"updateWeights",CValue::siBool, false);
	oCustomOperator.AddParameter(oPDef,oParam);

	oPDef = oFactory.CreateParamDef(L"wightsUpdated",CValue::siBool, false);
	oCustomOperator.AddParameter(oPDef,oParam);

	// ::TODEBUG::
	// Temporalmente lo pongo como un string porque no me aclaro como poner un grupo.
	//oPDef = oFactory.CreateParamDef(L"skeletonGroup", CValue::siString, L"");

	//oPDef = oFactory.CreateParamDef(L"inModel",CValue::siRef, NULL);
	//oCustomOperator.AddParameter(oPDef,oParam);

	//oPDef = oFactory.CreateParamDef(L"internal_scene", CValue::siPtr, NULL);
	//oCustomOperator.AddParameter(oPDef,oParam);
	oCustomOperator.PutAlwaysEvaluate(false);
	oCustomOperator.PutDebug(1);

	Application().LogMessage(L"Define fin...",siInfoMsg);

	return CStatus::OK;
}

SICALLBACK WeightComputation_Init( CRef& in_ctxt )
{
	Application().LogMessage(L"Init...",siInfoMsg);

	OperatorContext ctxt( in_ctxt );
	//Factory oFactory = Application().GetFactory();
	//Parameter oParam;

	// Incializacion de la escena
	scene* snc = new scene();
	ctxt.PutUserData( (CValue::siPtrType)snc );
	//ctxt.Pa("air_data", snc);

	//Primitive outPrim = ctxt.GetOutputTarget() ;
	//Geometry outGeom(outPrim.GetGeometry());

	Application().LogMessage(L"Fin init",siInfoMsg);

	return CStatus::OK;
}

SICALLBACK WeightComputation_Term( CRef& in_ctxt )
{
	OperatorContext ctxt( in_ctxt );
	Application().LogMessage(L"WeightComputation_Term called",siInfoMsg);


	return CStatus::OK;
}

SICALLBACK WeightComputation_Update( CRef& in_ctxt )
{
	Application().LogMessage(L"Update...",siInfoMsg);
	OperatorContext ctxt( in_ctxt );

	// Get Data from de scene.
	double weight_map = ctxt.GetParameterValue(L"weight_map");	
	CString dataFileName = ctxt.GetParameterValue(L"embeddingName");
	scene* escena = (scene*)(CValue::siPtrType)ctxt.GetUserData();

	bool processStatetoogle = ctxt.GetParameterValue(L"updateWeights");

	// Read the model connected
	Primitive inPrim(ctxt.GetInputValue( (LONG)0 ));
	Model obj;
	Model Modelroot;
	CRefArray models;
	//escena->models.push_back((object*)new Modelo(escena->getNewId()));


	switch(escena->state)
	{
	case CREATED:
		// Cargamos el modelo
		if(escena->models.size() == 0)
			LoadSoftImageModel(inPrim.GetGeometry(), escena);

		// Tenemos que crear la escena e inicializar todo.
		//LoadDataFromDisc(escena, dataFileName, ctxt);

		// Debug sobre el modelo cargado.
		if(escena->modelLoaded)
		{
			if(escena->models.size()== 0)
				Application().LogMessage(L"No hay modelo cargado.",siInfoMsg);

			for(unsigned int i = 0; i< escena->models.size(); i++)
			{
				int nverts = ((Modelo*)escena->models[i])->vn();
				int nfacets = ((Modelo*)escena->models[i])->fn();

				Application().LogMessage(L"Modelo: " + CString((int)i),siInfoMsg);
				Application().LogMessage(L"   Vertices: " + CString(nverts),siInfoMsg);
				Application().LogMessage(L"   Caras: " + CString(nfacets),siInfoMsg);
			}
		}

		// En el caso de tener que precomputar el grid se haría aquí.

/*		Modelroot = Application().GetActiveSceneRoot();
		models = Modelroot.GetModels(true);

		for(int i = 0; i< models.GetCount(); i++)
		{
			CString sname = ((Model)models[i]).GetName();
			Application().LogMessage(L"Buscando: " + sname, siInfoMsg);
			if(sname == CString(L"Mesh"))
				obj = ((Model)models[i]);
		}
*/
		// Cambiamos el estado y creamos el embedding.
		if(escena->modelLoaded && escena->skeletonLoaded && escena->embeddingLoaded)
		{

			// No puedo modificar nada de fuera del elemento...tiene que ser desde fuera de este operador.
			/*
			XSI::Envelope env;
			XSI::Group grp = ctxt.GetAttribute(L"skeletonGroup");
			Application().LogMessage(L"Enveloping: " + obj.GetName() + " with " + grp.GetName(),siInfoMsg);
			
			if(obj.ApplyEnvelope(grp.GetMembers(), siBranch, siBranch, env) != CStatus::OK)
			{
				Application().LogMessage(L"No se ha podido crear el envelope",siInfoMsg);
			}
			*/

			escena->state = RIGG;
		}
		break;

	case RIGG: //(F)
		if(processStatetoogle)
		{
			// 1. Actualizamos la posición actual como base.

			// 2. Recogemos los valores de cada elemento del grupo de deformadores

			// 3. Calculamos los nuevos pesos

			// 4. reasignamos los pesos

			// 5. Activamos la deformación
		
			// 6. Cambio de estado
			escena->state = ANIMATION;
		}
		else
		{
	
		}
		break;
	
	case ANIMATION: //(T)
		if(processStatetoogle)
		{

		}
		else
		{
			// 1. Desactivar deformación

			// 2. Reset de posiciones de los deformadores.

			// 3. Cambio de estado
			escena->state = RIGG;
		}

		break;
	
	default:
		Application().LogMessage(L"El estado del operador no esta bien definido.",siInfoMsg);
		break;
	}
	
	// 
	CRef output = ctxt.GetOutputTarget();

	Application().LogMessage(L"Update fin...",siInfoMsg);

	return CStatus::OK;
}

// Tip: Use the "Refresh" option on the Property Page context menu to 
// reload your script changes and re-execute the DefineLayout callback.
SICALLBACK WeightComputation_DefineLayout( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();
	oLayout.AddItem(L"embeddingName", L"Embedding computation");
	oLayout.AddItem(L"rig_anim_button", L"Rigging(F)/Animation(T)");
	return CStatus::OK;
}

SICALLBACK WeightComputation_PPGEvent( const CRef& in_ctxt )
{
	// This callback is called when events happen in the user interface
	// This is where you implement the "logic" code.
	
	// If the value of a parameter changes but the UI is not shown then this
	// code will not execute.  Also this code is not re-entrant, so any changes
	// to parameters inside this code will not result in further calls to this function
	
	Application app ;

	// The context object is used to determine exactly what happened
	// We don't use the same "PPG" object that is used from Script-based logic code 
	// but through the C++ API we can achieve exactly the same functionality.
	PPGEventContext ctxt( in_ctxt ) ;

	PPGEventContext::PPGEvent eventID = ctxt.GetEventID() ;

	if ( eventID == PPGEventContext::siOnInit )
	{
		// This event meant that the UI was just created.
		// It gives us a chance to set some parameter values.
		// We could even change the layout completely at this point.

		// Get all inspected CustomOperator objects
		CRefArray props = ctxt.GetInspectedObjects();
		
		for (LONG i=0; i<props.GetCount( ); i++)
		{
			CustomOperator prop( props[i] );
			app.LogMessage( L"OnInit called for " + prop.GetFullName(), siVerboseMsg ) ;
		}				

		/* If you regenerate the layout then call this:
		ctxt.PutAttribute(L"Refresh",true);
		*/
	}
	else if ( eventID == PPGEventContext::siOnClosed )
	{
		// This event meant that the UI was just closed by the user.

		// Get all inspected CustomOperator objects
		CRefArray props = ctxt.GetInspectedObjects();
		
		for (LONG i=0; i<props.GetCount( ); i++)
		{
			CustomOperator prop( props[i] );
			app.LogMessage( L"OnClosed called for " + prop.GetFullName(), siVerboseMsg ) ;
		}						
	}	
	else if ( eventID == PPGEventContext::siButtonClicked )
	{
		// If there are multiple buttons 
		// we can use this attribute to figure out which one was clicked.
		CValue buttonPressed = ctxt.GetAttribute( L"Button" ) ;	

		// Get all inspected CustomOperator objects
		CRefArray props = ctxt.GetInspectedObjects();
		
		for (LONG i=0; i<props.GetCount( ); i++)
		{
			CustomOperator prop( props[i] );
			app.LogMessage( L"Button pressed: " + buttonPressed.GetAsText() + CString(" while inspecting " ) + prop.GetFullName() );
		}		
	}
	else if ( eventID == PPGEventContext::siTabChange )
	{
		// We will be called when the PPG is first opened
		// and every time the tab changes

		// Retrieve the label of the tab that is now active
		CValue tabLabel = ctxt.GetAttribute( L"Tab" ) ;

		// Get all inspected CustomOperator objects
		CRefArray props = ctxt.GetInspectedObjects();
		
		for (LONG i=0; i<props.GetCount( ); i++)
		{
			CustomOperator prop( props[i] );
			app.LogMessage( L"Tab changed to: " + tabLabel.GetAsText() + CString(" while inspecting " ) + prop.GetFullName() );
		}		
	}
	else if ( eventID == PPGEventContext::siParameterChange )
	{
		// For this event the Source of the event is the parameter
		// itself
		Parameter changed = ctxt.GetSource() ;	
		CustomOperator prop = changed.GetParent() ;	
		CString paramName = changed.GetScriptName() ; 

		app.LogMessage( L"Parameter Changed: " + paramName, siVerboseMsg ) ;
	}

	return CStatus::OK ;
}

