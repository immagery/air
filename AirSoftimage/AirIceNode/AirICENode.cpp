// AirICENode Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Jan 8 11:12:54 UTC+0100 2013 by CHUS
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include "AirICENode.h"

#include <xsi_dataarray2D.h>
#include <xsi_floatarray.h>

#include <xsi_progressbar.h>
#include <xsi_uitoolkit.h>

#include <map>

#include <Computation\Segmentation.h>
#include <DataStructures\DataStructures.h>

using namespace XSI; 
using namespace MATH; 

#define DEFAULT_SCENE_FILE L"I:/Chus/phd_dev/Data/models/ternera_scene.txt"

CStatus RegisterAirWeightsContextualization( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"AirWeightsContextualization",L"Air Weights Contextualization");

	CStatus st;
	st = nodeDef.PutColor(154,188,102);
	st.AssertSucceeded( ) ;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_101);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_102);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_pointPositions,
		ID_G_101,siICENodeDataLong,
		siICENodeStructureSingle,
		siICENodeContextComponent0D,
		L"pointIndx",
		L"pointIndx",
		MATH::CVector3f(1.0,1.0,1.0),
		CValue(),
		CValue(),
		ID_UNDEF,
		ID_UNDEF,
		ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_inWeights,
		ID_G_102,
		siICENodeDataFloat,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"inWeights",
		L"inWeights");

	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_defIdsCount,
		ID_G_102,
		siICENodeDataLong,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"defIdsCount",
		L"defIdsCount");
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_pointsCount,
		ID_G_102,
		siICENodeDataLong,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"pointsCount",
		L"pointsCount");
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(
		ID_OUT_weightsPerPoint,
		siICENodeDataFloat,
		siICENodeStructureArray,
		siICENodeContextComponent0D,
		L"weightsPerPoint",
		L"weightsPerPoint");
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Air nodes");

	return CStatus::OK;
}


SICALLBACK AirWeightsContextualization_Evaluate( ICENodeContext& in_ctxt )
{
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );

	switch( out_portID )
	{		
	case ID_OUT_weightsPerPoint :
		{
			// Get the output port array ...			
			CDataArray2DFloat outData( in_ctxt );

			// Get the input data buffers for each port
			CDataArray2DFloat inWeightsData( in_ctxt, ID_IN_inWeights );
			CDataArrayLong pointIdsData( in_ctxt, ID_IN_pointPositions );
			CDataArrayLong defIdsCountData( in_ctxt, ID_IN_defIdsCount );
			CDataArrayLong pointsCountData( in_ctxt, ID_IN_pointsCount );

			if(inWeightsData.GetCount() == 0) break;
			if(defIdsCountData.GetCount() == 0) break;
			if(pointsCountData.GetCount() == 0) break;
			if(pointIdsData.GetCount() == 0) break;

			// We need a CIndexSet to iterate over the data 		
			CIndexSet indexSet( in_ctxt );
			int iter = 0;

			for(CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{
				CDataArray2DFloat::Accessor outAccessor = outData.Resize( it, defIdsCountData[it]);
				CDataArray2DFloat::Accessor inWeightsSubArray = inWeightsData[it];
				
				ULONG pointId = pointIdsData[it];
				ULONG defCount = defIdsCountData[it];

				float sum = 0; 
				// Copiamos los datos que sean necesarios.
				for(ULONG i = 0; i< defCount; i++)
				{
					
					if(inWeightsSubArray.GetCount() > pointId*defCount+i)
					{
						float valueFloat = inWeightsSubArray[pointId*defCount+i];
						sum += valueFloat;
						outAccessor[i] = valueFloat;
					}
					else
						Application().LogMessage( L"Out of range: " + CString(pointId) + L" " + CString(i) + L" " + CString(pointsCountData[it]) ,siInfoMsg);
				
				}
				if(sum < 1)
				{
					//Application().LogMessage( L"La suma de pesos no es 1: " + CString(sum) ,siInfoMsg);
				}
				iter++;
			}
		}
		break;

	};

	return CStatus::OK;
}

void buildSkeleton(joint* jt, ChainBone& bone)
{
	ChainBone myChainBoneJt;
	bone.AddPrimitive(L"Bone", CString(jt->sName.c_str()) , myChainBoneJt);
	myChainBoneJt.PutLocalTranslation(MATH::CVector3(jt->worldPosition[0], jt->worldPosition[1], jt->worldPosition[2]));
	//myChainBone.PutLocalRotation(MATH::CVector3(rotX, rotY, rotZ));
	//myChainBone.PutParameterValue(L"Length", MATH::CVector3(posX, posY, posZ).GetLength());
	myChainBoneJt.PutParameterValue(L"Size", 0.25);

	for(unsigned int i = 0; i< jt->childs.size(); i++)
	{
		buildSkeleton(jt->childs[i], myChainBoneJt);
	}
}

void buildSceneSkeletons(scene* escena)
{
	if(escena->skeletons.size() == 0) return;

	skeleton* skt = (skeleton*)escena->skeletons.back();

	Application app;
	Model Modelroot = app.GetActiveSceneRoot();
	ChainBone myChainBone;
	Modelroot.AddPrimitive(L"Bone", CString(skt->root->sName.c_str()) , myChainBone);

	myChainBone.PutLocalTranslation(MATH::CVector3(skt->root->worldPosition[0], skt->root->worldPosition[1], skt->root->worldPosition[2]));
	//myChainBone.PutLocalRotation(MATH::CVector3(rotX, rotY, rotZ));
	//myChainBone.PutParameterValue(L"Length", MATH::CVector3(posX, posY, posZ).GetLength());
	myChainBone.PutParameterValue(L"Size", 0.25);

	for(unsigned int i = 0; i< skt->root->childs.size(); i++)
	{
		buildSkeleton(skt->root->childs[i], myChainBone);
	}

	//myChainBone.PutParameterValue(L"axisx", ojX);
	//myChainBone.PutParameterValue(L"axisy", ojY);
	//qmyChainBone.PutParameterValue(L"axisz", ojZ);

	//ChainRoot myChainRoot;

	//ChainBone myChainBone1;
	//root.AddPrimitive(L"Bone", L"rootBone", myChainBone1);

	//ChainBone myChainBone1;
	//myChainRoot.AddBone(MATH::CVector3(3,3,3),siChainBonePin,L"",myChainBone1);
	//myChainBone1.Add

	//ChainBone myChainBone2;
	//myChainBone1.AddPrimitive(L"Bone", L"bone001", myChainBone2);
	//myChainRoot.AddBone(MATH::CVector3(6,0,0),siChainBoneBallJoint,L"",myChainBone2);

}

void readBone(skeleton* skt, joint* root, FILE* fout, scene* escena, Group& grp)
{
	int num1 = 0; char str[1000];
	float posX, posY, posZ;
	float rotX, rotY, rotZ;
	float ojX, ojY, ojZ;
	float wpX, wpY, wpZ;

	fscanf(fout, "%s", &str[0]);
	fscanf(fout, "%f", &posX);
	fscanf(fout, "%f", &posY);
	fscanf(fout, "%f", &posZ);

	fscanf(fout, "%f", &rotX);
	fscanf(fout, "%f", &rotY);
	fscanf(fout, "%f", &rotZ);

	fscanf(fout, "%f", &ojX);
	fscanf(fout, "%f", &ojY);
	fscanf(fout, "%f", &ojZ);

	fscanf(fout, "%f", &wpX);
	fscanf(fout, "%f", &wpY);
	fscanf(fout, "%f", &wpZ);

	fscanf(fout, "%d", &num1);

	root->sName = str;
	root->resetTransformation();
	root->addTranslation(posX, posY, posZ);
	root->addRotation(rotX, rotY, rotZ);
	root->setJointOrientation(ojX,ojY,ojZ);

	Application app;
	Model scnRoot = app.GetActiveSceneRoot();

	XSI::Null nullObj; 
	scnRoot.AddNull( CString(str) , nullObj);
	grp.AddMember(nullObj);

	CustomProperty cpset;
	nullObj.AddCustomProperty(L"AirProperties", false, cpset );

	Parameter id;
	cpset.AddParameter( L"jointId", CValue::siInt4, siReadOnly, L"jointId", L"Id for Air Computations", (LONG)root->nodeId, (LONG)-1, (LONG)99999, (LONG)-1, (LONG)99999, id );
	
	nullObj.PutParameterValue(L"Size", 0.08);
	nullObj.PutParameterValue(L"shadow_icon", (LONG) 2);

	//nullObj.PutParameterValue(L"nrotx", rotX);
	//nullObj.PutParameterValue(L"nroty", posY);
	//nullObj.PutParameterValue(L"nrotz", posZ);

	nullObj.PutParameterValue(L"nposx", wpX);
	nullObj.PutParameterValue(L"nposy", wpY);
	nullObj.PutParameterValue(L"nposz", wpZ);

	//myChainBone.PutLocalTranslation(MATH::CVector3(posX, posY, posZ));
	//myChainBone.PutLocalRotation(MATH::CVector3(rotX, rotY, rotZ));
	//myChainBone.PutParameterValue(L"Length", MATH::CVector3(posX, posY, posZ).GetLength());
	//myChainBone.PutParameterValue(L"Size", 0.5);

	//myChainBone.PutParameterValue(L"axisx", ojX);
	//myChainBone.PutParameterValue(L"axisy", ojY);
	//qmyChainBone.PutParameterValue(L"axisz", ojZ);

	//root->setJointId(scene::getNewId());

	root->setWorldPosition(Point3d(wpX, wpY, wpZ));
	skt->joints.push_back(root);
	skt->jointRef[root->nodeId] = root;

	for(int i = 0; i< num1; i++)
	{
		joint* jt = new joint(root, escena->getNewId());
		root->pushChild(jt);
		//ChainBone myChainBoneJt;
		//myChainBone.AddPrimitive(L"Bone", CString(jt->sName.c_str()) , myChainBoneJt);
		//myChainBoneJt.PutParameterValue(L"local.nrotx", ojX);
		//myChainBoneJt.PutParameterValue(L"local.nroty", ojY);
		//myChainBoneJt.PutParameterValue(L"local.nrotz", ojZ);

		//printf("anadimos el joint: %s %f %f %f con %d hijos\n",str, posX, posY-pos.Y(), posZ-pos.Z(),num1);
		readBone(skt, jt, fout, escena, grp);
	}
}

void readBone(skeleton* skt, joint* root, FILE* fout, scene* escena)
{
	int num1 = 0; char str[1000];
	float posX, posY, posZ;
	float rotX, rotY, rotZ;
	float ojX, ojY, ojZ;
	float wpX, wpY, wpZ;

	fscanf(fout, "%s", &str[0]);
	fscanf(fout, "%f", &posX);
	fscanf(fout, "%f", &posY);
	fscanf(fout, "%f", &posZ);

	fscanf(fout, "%f", &rotX);
	fscanf(fout, "%f", &rotY);
	fscanf(fout, "%f", &rotZ);

	fscanf(fout, "%f", &ojX);
	fscanf(fout, "%f", &ojY);
	fscanf(fout, "%f", &ojZ);

	fscanf(fout, "%f", &wpX);
	fscanf(fout, "%f", &wpY);
	fscanf(fout, "%f", &wpZ);

	fscanf(fout, "%d", &num1);

	root->sName = str;
	root->resetTransformation();
	root->addTranslation(posX, posY, posZ);
	root->addRotation(rotX, rotY, rotZ);
	root->setJointOrientation(ojX,ojY,ojZ);

	//Application app;
	//Model scnRoot = app.GetActiveSceneRoot();

	//XSI::Null nullObj; 
	//scnRoot.AddNull( CString(str) , nullObj);
	//grp.AddMember(nullObj);

	//CustomProperty cpset;
	//nullObj.AddCustomProperty(L"AirProperties", false, cpset );

	//Parameter id;
	//cpset.AddParameter( L"jointId", CValue::siInt4, siReadOnly, L"jointId", L"Id for Air Computations", (LONG)root->nodeId, (LONG)-1, (LONG)99999, (LONG)-1, (LONG)99999, id );

	//nullObj.PutParameterValue(L"Size", 0.08);
	//nullObj.PutParameterValue(L"shadow_icon", (LONG) 2);

	//nullObj.PutParameterValue(L"nrotx", rotX);
	//nullObj.PutParameterValue(L"nroty", posY);
	//nullObj.PutParameterValue(L"nrotz", posZ);

	//nullObj.PutParameterValue(L"nposx", wpX);
	//nullObj.PutParameterValue(L"nposy", wpY);
	//nullObj.PutParameterValue(L"nposz", wpZ);

	//myChainBone.PutLocalTranslation(MATH::CVector3(posX, posY, posZ));
	//myChainBone.PutLocalRotation(MATH::CVector3(rotX, rotY, rotZ));
	//myChainBone.PutParameterValue(L"Length", MATH::CVector3(posX, posY, posZ).GetLength());
	//myChainBone.PutParameterValue(L"Size", 0.5);

	//myChainBone.PutParameterValue(L"axisx", ojX);
	//myChainBone.PutParameterValue(L"axisy", ojY);
	//qmyChainBone.PutParameterValue(L"axisz", ojZ);

	//root->setJointId(scene::getNewId());

	root->setWorldPosition(Point3d(wpX, wpY, wpZ));
	skt->joints.push_back(root);
	skt->jointRef[root->nodeId] = root;

	for(int i = 0; i< num1; i++)
	{
		joint* jt = new joint(root, escena->getNewId());
		root->pushChild(jt);
		//ChainBone myChainBoneJt;
		//myChainBone.AddPrimitive(L"Bone", CString(jt->sName.c_str()) , myChainBoneJt);
		//myChainBoneJt.PutParameterValue(L"local.nrotx", ojX);
		//myChainBoneJt.PutParameterValue(L"local.nroty", ojY);
		//myChainBoneJt.PutParameterValue(L"local.nrotz", ojZ);

		//printf("anadimos el joint: %s %f %f %f con %d hijos\n",str, posX, posY-pos.Y(), posZ-pos.Z(),num1);
		readBone(skt, jt, fout, escena);
	}
}

void readSkeleton(string fileName, scene* escena, OperatorContext& ctxt)
{
     FILE* fout;
     fout = fopen(fileName.c_str(), "r");

     if(!fout) 
	 {
		 Application().LogMessage( L"No puedo abrir el fichero de esqueleto. " ,siInfoMsg);
		 return;
		 //printf("No he podido abrir el fichero de esqueleto.\n"); fflush(0);
	 }

     int num1 = 0;

     fscanf(fout, "%d", &num1);
	 Application().LogMessage( L"Hay tantos esqueletos: " + num1 ,siInfoMsg);

     for(int i = 0; i< num1; i++)
     {
         // Skeleton creation
         skeleton* skt = new skeleton();
         skt->sName = "skeleton" + i;

		 Application app;
		 Model scnRoot = app.GetActiveSceneRoot();
		 Group grp;
		 scnRoot.AddGroup(NULL, CString(skt->sName.c_str()), false, grp);

		 ctxt.PutAttribute(L"skeletonGroup", CRef(grp));

         //Root joint Creation
         skt->root = new joint(scene::getNewId());

         readBone(skt, skt->root, fout, escena, grp);
         skt->update();

         //printf("Map size: %d\n", skt->jointRef.size()); fflush(0);
         //map<int, joint*>::iterator it = skt->jointRef.begin();
         /*for(int jr = 0; jr < skt->jointRef.size(); jr++)
         {
             printf("  Key: %d, Value: %d\n", (*it).first, ((joint*)((*it).second))->nodeId); fflush(0);
             it++;
         }
		 */

         //readBones(skt, fout);
         escena->skeletons.push_back(skt);
     }

	 //buildSceneSkeletons(escena);

     fclose(fout);
 }

void readSkeleton(string fileName, scene* escena)
{
     FILE* fout;
     fout = fopen(fileName.c_str(), "r");

     if(!fout) 
	 {
		 Application().LogMessage( L"No puedo abrir el fichero de esqueleto. " ,siInfoMsg);
		 return;
		 //printf("No he podido abrir el fichero de esqueleto.\n"); fflush(0);
	 }

     int num1 = 0;

     fscanf(fout, "%d", &num1);
	 Application().LogMessage( L"Hay tantos esqueletos: " + num1 ,siInfoMsg);

     for(int i = 0; i< num1; i++)
     {
         // Skeleton creation
         skeleton* skt = new skeleton();
         skt->sName = "skeleton" + i;

		 //Application app;
		 //Model scnRoot = app.GetActiveSceneRoot();
		 //Group grp;
		 //scnRoot.AddGroup(NULL, CString(skt->sName.c_str()), false, grp);

		 //ctxt.PutAttribute(L"skeletonGroup", CRef(grp));

         //Root joint Creation
         skt->root = new joint(scene::getNewId());
         readBone(skt, skt->root, fout, escena);
         skt->update();

         //printf("Map size: %d\n", skt->jointRef.size()); fflush(0);
         //map<int, joint*>::iterator it = skt->jointRef.begin();
         /*for(int jr = 0; jr < skt->jointRef.size(); jr++)
         {
             printf("  Key: %d, Value: %d\n", (*it).first, ((joint*)((*it).second))->nodeId); fflush(0);
             it++;
         }
		 */

         //readBones(skt, fout);
         escena->skeletons.push_back(skt);
     }

	 //buildSceneSkeletons(escena);

     fclose(fout);
 }

bool LoadSoftImageModel(XSI::Geometry& geom_soft, scene* escena)
{
	//XSI::Geometry geom_soft(geom_ref);
	CVector3Array posArray(geom_soft.GetPoints().GetPositionArray());
	//Application().LogMessage( L"LoadSoftImageModel verts: " + CString(posArray.GetCount()) ,siInfoMsg);

	// Cogemos el path	
	CString path = Application().GetActiveProject().GetPath() + L"\\tempFiles\\";
	CString rtn = path + L"off_model_temp.off";

	//Application().LogMessage( L"Utilizando el path temporal: " + rtn ,siInfoMsg);

	Application().LogMessage( L"Fichero temporal: " + rtn,siInfoMsg);

	// Creamos un fichero nuevo.
	FILE* fout;
	_mkdir(path.GetAsciiString());
	fout = fopen(rtn.GetAsciiString(), "w");

	if(fout == NULL) return false;

	Application().LogMessage( L"Lectura del modelo" ,siInfoMsg);

	int totalVerts = geom_soft.GetPoints().GetCount();
	int totalTriangles = geom_soft.GetFacets().GetCount();
	int colors = 0;

	Application().LogMessage( L"Vertices: " + CString(totalVerts) ,siInfoMsg);
	Application().LogMessage( L"Triangulos " + CString(totalTriangles) ,siInfoMsg);
	Application().LogMessage( L"Colores " + CString(colors) ,siInfoMsg);

	fprintf(fout, "OFF\n");
	fprintf(fout, "%d %d %d\n",totalVerts, totalTriangles, colors );

	// Guardamos los puntos.
	//CVector3Array posArray(geom_soft.GetPoints().GetPositionArray());
	
	for (long p=0; p<posArray.GetCount(); p++ )
	{
		fprintf(fout,"%f %f %f\n" , posArray[p].GetX(), posArray[p].GetY(), posArray[p].GetZ());
	}

	// Guardamos las caras
	CFacetRefArray facets(geom_soft.GetFacets());
	for (long f=0; f<facets.GetCount(); f++ )
	{
		Facet facet(facets[f]);
		CPointRefArray verts(facet.GetPoints());

		fprintf(fout, "3 ");
		for (long v=0; v<verts.GetCount(); v++ )
		{
			int idx = ((Point)verts[v]).GetIndex();
			fprintf(fout,"%d " , idx);
		}

		fprintf(fout, "\n");
	}

	fclose(fout);

	escena->models.push_back((object*)new Modelo(escena->getNewId()));
	Modelo* m_air = (Modelo*)escena->models.back();
	m_air->loadModel(rtn.GetAsciiString(), "off_model_temp", "off", path.GetAsciiString());
	escena->modelLoaded = true;
	
	Application().LogMessage( L"Modelo cargado.",siInfoMsg);
	return true;
}

bool LoadICEModel(XSI::CICEGeometry& geom, Modelo* m_air, scene* escena)
{
	ULONG totalVerts = geom.GetPointPositionCount();
	ULONG totalTriangles = geom.GetPolygonCount();

	//Leemos los vertices
	CDoubleArray vertPos;
	geom.GetPointPositions(vertPos);

	m_air->nodes.resize(totalVerts);
	for (long p=0; p<totalVerts; p++ )
	{
		m_air->nodes[p] = new GraphNode(p);
		m_air->nodes[p]->position = Point3d(vertPos[p*3],vertPos[p*3+1],vertPos[p*3+2]);
	}

	// Leemos las caras.
	m_air->triangles.resize(totalTriangles);
	CLongArray sizes;   // sizes holds the number of points per polygon
	CLongArray indices; // indices holds the polygon indices and are used for indexing the point values
	geom.GetPolygonIndices( sizes, indices );

	ULONG nOffset = 0;
	for (ULONG f=0; f<totalTriangles; f++ )
	{
		m_air->triangles[f] = new GraphNodePolygon(f);
		m_air->triangles[f]->verts.resize(sizes[f]);

		vector<int> indexes;
		for(int j = 0; j< sizes[f]; j++)
		{
			int idx = indices[nOffset];
			m_air->triangles[f]->verts[j] = m_air->nodes[idx];
			indexes.push_back(idx);
			nOffset++;
		}

		for(int j = 0; j< sizes[f]; j++)
		{
			m_air->nodes[indexes[j]]->connections.push_back(m_air->nodes[indexes[(j+1)%sizes[f]]]);
			m_air->nodes[indexes[(j+1)%sizes[f]]]->connections.push_back(m_air->nodes[indexes[j]]);
		}
	}

	escena->modelLoaded = true;

	return true;
}

bool CreateICEModel(XSI::CICEGeometry& geom, Modelo* m_air, scene* escena)
{
	//CVector3Array posArray(geom_soft.GetPoints().GetPositionArray());
	//Application().LogMessage( L"LoadSoftImageModel verts: " + CString(posArray.GetCount()) ,siInfoMsg);

	Application().LogMessage( L"Lectura del modelo" ,siInfoMsg);

	ULONG totalVerts = geom.GetPointPositionCount();
	ULONG totalTriangles = geom.GetPolygonCount();
	ULONG colors = 0;

	Application().LogMessage( L"Vertices: " + CString(totalVerts) ,siInfoMsg);
	Application().LogMessage( L"Triangulos " + CString(totalTriangles) ,siInfoMsg);

	// Cogemos el path	
	CString path = Application().GetActiveProject().GetPath() + L"\\tempFiles\\";
	CString rtn = path + L"off_model_temp.off";

	//Application().LogMessage( L"Utilizando el path temporal: " + rtn ,siInfoMsg);

	Application().LogMessage( L"Fichero temporal: " + rtn,siInfoMsg);

	// Creamos un fichero nuevo.
	FILE* fout;
	_mkdir(path.GetAsciiString());
	fout = fopen(rtn.GetAsciiString(), "w");

	if(fout == NULL) return false;

	fprintf(fout, "OFF\n");
	fprintf(fout, "%d %d %d\n",totalVerts, totalTriangles, colors );

	// Guardamos los puntos.
	//CVector3Array posArray(geom_soft.GetPoints().GetPositionArray());

	CDoubleArray vertPos;
	geom.GetPointPositions(vertPos);
	for (long p=0; p<vertPos.GetCount(); p++ )
	{
		if(p%3 == 0 && p > 0)
			fprintf(fout,"\n");

		fprintf(fout,"%f " , vertPos[p]);
	}

	CLongArray sizes;   // sizes holds the number of points per polygon
	CLongArray indices; // indices holds the polygon indices and are used for indexing the point values
	geom.GetPolygonIndices( sizes, indices );

	// Guardamos las caras
	ULONG nOffset = 0;
	fprintf(fout, "\n");
	for (ULONG f=0; f<totalTriangles; f++ )
	{
		fprintf(fout, "%d ", sizes[f]);
		for (ULONG j=0; j<(ULONG)sizes[f]; j++, nOffset++ )
		{
			fprintf(fout,"%d " , indices[nOffset]);
		}

		fprintf(fout, "\n");
	}

	fclose(fout);
	
	m_air = new Modelo(escena->getNewId());
	escena->models.push_back(m_air);
	
	m_air->loadModel(rtn.GetAsciiString(), 
					 "off_model_temp", 
					 "off", 
					 path.GetAsciiString());

	escena->modelLoaded = true;

	Application().LogMessage( L"Modelo cargado.",siInfoMsg);
	return true;
}

/*
bool LoadDataFromDisc(scene* escena, CString sFileName, OperatorContext& ctxt)
{
	if (sFileName.IsEmpty()) return false; // No hay fichero especificado

	ifstream myfile (sFileName.GetAsciiString());

	if (!myfile.is_open()) return false; // No lo ha podido abrir.

	string line;
	string sSceneName, sPath, sTotalPath, sModelFile, sSkeletonFile, sEmbeddingFile, sGridFile;
	if (myfile.is_open())
	{
		getline (myfile,sSceneName); getline (myfile,line);
		getline (myfile,sTotalPath); getline (myfile,line);
		getline (myfile,sPath); getline (myfile,line); getline (myfile,line);
		getline (myfile,sModelFile); getline (myfile,line); getline (myfile,line);
		getline (myfile,sSkeletonFile); getline (myfile,line); getline (myfile,line);
		getline (myfile,sEmbeddingFile); getline (myfile,line); getline (myfile,line);
		getline (myfile,sGridFile); 
		myfile.close();
	}

	Application().LogMessage( L"Cargando datos guardados...",siInfoMsg);
	Application().LogMessage( L"sSceneName: " + CString(sSceneName.c_str()) ,siInfoMsg);
	//Application().LogMessage( L"sPath: " + CString(sPath.c_str()) ,siInfoMsg);
	//Application().LogMessage( L"sModelFile: " + CString(sModelFile.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sSkeletonFile: " + CString(sSkeletonFile.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sEmbeddingFile: " + CString(sEmbeddingFile.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sGridFile: " + CString(sGridFile.c_str()) ,siInfoMsg);

	// Leer esqueleto
	string sFile = sTotalPath;
	sFile.append(sPath).append(sSkeletonFile);
	ifstream SkeletonFile(sFile.c_str());
	if (!SkeletonFile.is_open()) 
	{
		Application().LogMessage( L"No he podido abrir el fichero de esqueleto: " + CString(sSkeletonFile.c_str()) ,siInfoMsg);
		return false;
	}
	SkeletonFile.close();
	readSkeleton(sFile, escena, ctxt);
	escena->skeletonLoaded = true;
	//buildSceneSkeletons(escena);

	// Si no se ha cargado un modelo antes, pasamos.
	if(escena->models.size() == 0) return false;

	// Leer embedding
	sFile = sTotalPath;
	sFile.append(sPath).append(sEmbeddingFile);
	ifstream embeddingFile(sFile.c_str());
	if (!embeddingFile.is_open()) 
	{
		Application().LogMessage( L"No he podido abrir el embedding: " + CString(sFile.c_str()) ,siInfoMsg);
		return false;
	}
	SkeletonFile.close();
	ReadEmbedding(sFile, ((Modelo*)escena->models.back())->embedding);
	escena->embeddingLoaded = true;
	Application().LogMessage( L"Embedding cargado." ,siInfoMsg);

	// Leer grid precomputado.
	sFile = sTotalPath;
	sFile.append(sPath).append(sGridFile);
	escena->visualizers.push_back(new gridRenderer(escena->getNewId()));
	gridRenderer* gr = (gridRenderer*)escena->visualizers.back();
	ifstream gridFile(sFile.c_str());
	if (!gridFile.is_open()) 
	{
		Application().LogMessage( L"No he podido abrir el grid precomputado: " + CString(sFile.c_str()) ,siInfoMsg);
		return false;
	}
	gr->grid.LoadGridFromFile(sFile);
	Application().LogMessage( L"Grid cargado." ,siInfoMsg);

	return true;
}
*/

bool LoadDataFromDiscICE(scene* escena, CString sFileName)
{
	if (sFileName.IsEmpty()) return false; // No hay fichero especificado

	const char* charFileName = sFileName.GetAsciiString();
	ifstream myfile(charFileName);

	if (!myfile.is_open()) return false; // No lo ha podido abrir.

	string line;
	string sSceneName, sPath, sTotalPath, sModelFile, sSkeletonFile, sEmbeddingFile, sGridFile;
	getline (myfile,sSceneName); getline (myfile,line);
	getline (myfile,sTotalPath); getline (myfile,line);
	getline (myfile,sPath); getline (myfile,line); getline (myfile,line);
	getline (myfile,sModelFile); getline (myfile,line); getline (myfile,line);
	getline (myfile,sSkeletonFile); getline (myfile,line); getline (myfile,line);
	getline (myfile,sEmbeddingFile); getline (myfile,line); getline (myfile,line);
	getline (myfile,sGridFile); 

	myfile.close();

	Application().LogMessage( L"Cargando datos guardados...",siInfoMsg);
	Application().LogMessage( L"sSceneName: " + CString(sSceneName.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sSkeletonFile: " + CString(sSkeletonFile.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sEmbeddingFile: " + CString(sEmbeddingFile.c_str()) ,siInfoMsg);
	Application().LogMessage( L"sGridFile: " + CString(sGridFile.c_str()) ,siInfoMsg);

	// Leer esqueleto
	string sFile = sTotalPath;

	// Si no se ha cargado un modelo antes, pasamos.
	if(escena->models.size() == 0) return false;
	Modelo* m = (Modelo*)escena->models.back();

	// A. Leer embedding
	sFile = sTotalPath;
	sFile.append(sPath).append(sEmbeddingFile);
	ifstream embeddingFile(sFile.c_str());
	if (!embeddingFile.is_open()) 
	{
		Application().LogMessage( L"No he podido abrir el embedding: " + CString(sFile.c_str()) ,siInfoMsg);
		return false;
	}
	embeddingFile.close();
	ReadEmbedding(sFile, m->embedding);
	escena->embeddingLoaded = true;
	Application().LogMessage( L"Embedding cargado." ,siInfoMsg);

	// B. Leer grid precomputado.
	/*
	if(!escena->initialized)
		m->grid = new grid3d();
	
	sFile = sTotalPath;
	sFile.append(sPath).append(sGridFile);
	ifstream gridFile(sFile.c_str());
	if (!gridFile.is_open()) 
	{
		Application().LogMessage( L"No he podido abrir el grid precomputado: " + CString(sFile.c_str()) ,siInfoMsg);
		return false;
	}
	m->grid->LoadGridFromFile(sFile);
	Application().LogMessage( L"Grid cargado." ,siInfoMsg);
	
	escena->gridLoadedFromDisc = true;
	*/
	return true;
}

CStatus RegisterAirICENode( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"AirICENode",L"AirICENode");

	CStatus st;
	st = nodeDef.PutThreadingModel(XSI::siICENodeSingleThreading);
	st.AssertSucceeded( ) ;

	st = nodeDef.PutColor(154,188,102);
	st.AssertSucceeded( ) ;

	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_Model,
		ID_G_100,
		siICENodeDataGeometry,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"inModel",
		L"inModel",
		CValue());

	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_NodePositions,
		ID_G_100,
		siICENodeDataVector3,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"controlAirNodesSet",
		L"controlAirNodesSet",
		MATH::CVector3f(0.0,0.0,0.0));
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_NodeIds,
		ID_G_100,
		siICENodeDataLong,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"controlAirNodesSetIds",
		L"controlAirNodesSetIds",
		CValue());
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_DefParentIds,
		ID_G_100,
		siICENodeDataLong,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"parentingRelationship",
		L"Relation of parenting between deformers",
		CValue());
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(
		ID_OUT_outWeights,
		siICENodeDataFloat,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"outWeights",
		L"outWeights");
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_sceneScale,
		ID_G_100,
		siICENodeDataFloat,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"Scene Scale",
		L"Scene Scale",
		DEFAULT_SCENE_FILE);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_globalSmoothing,
		ID_G_100,
		siICENodeDataFloat,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"Global Smoothing",
		L"Global Smoothing",
		DEFAULT_SCENE_FILE);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_expansionFactors,
		ID_G_100,
		siICENodeDataFloat,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"controlAirNodesExpansion",
		L"nodes expansion",
		CValue());
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_propagationFactors,
		ID_G_100,
		siICENodeDataFloat,
		siICENodeStructureArray,
		siICENodeContextSingleton,
		L"controlAirNodesPropagation",
		L"nodes propagation",
		CValue());
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_embeddingFileName,
		ID_G_100,
		siICENodeDataString,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"ModelProcesedData",
		L"ModelProcesedData",
		DEFAULT_SCENE_FILE);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_rigging_animation,
		ID_G_100,siICENodeDataBool,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"rigging_animation",
		L"rigging_animation",
		false);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(
		ID_IN_rigging_evaluate,
		ID_G_100,siICENodeDataBool,
		siICENodeStructureSingle,
		siICENodeContextSingleton,
		L"rigging_evaluation",
		L"rigging_evaluation",
		false);
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Air nodes");
	return CStatus::OK;
}


// Quizás no sirve el joint ID, hay que conseguir que vayan a la par
CStatus UpdateSkeletonParameters(CDataArray2DLong::Accessor& ids,
								CDataArray2DFloat::Accessor&  nodesExpansion,
								CDataArray2DFloat::Accessor&  smoothingFactors,
								scene* escena)
{
	// We instantiate every joint
	for(unsigned int id = 0; id < ids.GetCount(); id++)
	{
		int currentId = ids[id];
		joint* jt = escena->deformerRef[currentId];
		if(!jt) continue;

		// Asignamos el valor de expansion.
		if(nodesExpansion.GetCount() == 0)
			jt->expansion = 1;
		else
			jt->expansion = nodesExpansion[id];

		// Asignamos el valor de expansion.
		if(smoothingFactors.GetCount() == 0)
			jt->smoothness = 1;
		else
			jt->smoothness = smoothingFactors[id];
	}
	
	return CStatus::OK;
}

CStatus CreateSkeletonFromParentingRelations(CDataArray2DLong::Accessor& ids,
											 CDataArray2DVector3f::Accessor& defPositions, 
											 CDataArray2DLong::Accessor&  relations,
											 //CDataArray2DFloat::Accessor&  nodesExpansion,
											 //CDataArray2DFloat::Accessor&  smoothingFactors,
											 scene* escena,
											 bool buildSkeleton = false)
{
	// Clean the skeleton structure.
	for(unsigned int i = 0; i< escena->skeletons.size(); i++)
	{
		delete escena->skeletons[i];
	}
	escena->skeletons.clear();
	escena->defIds.clear();

	vector<joint*> allDeformers;
	vector<int> indices;
	
	// We instantiate every joint
	map<int, int> lookup;
	lookup.clear();
	for(unsigned int id = 0; id < ids.GetCount(); id++)
	{
		joint* jt = new joint(escena->getNewId());
		jt->setWorldPosition(Point3d(defPositions[id].GetX(), 
									 defPositions[id].GetY(), 
									 defPositions[id].GetZ()));

		// Asignamos el valor de expansion.
		//if(nodesExpansion.GetCount() == 0)
		//	jt->expansion = 1;
		//else
		//	jt->expansion = nodesExpansion[id];

		// Asignamos el valor de expansion.
		//if(smoothingFactors.GetCount() == 0)
		//	jt->smoothness = 1;
		//else
		//	jt->smoothness = smoothingFactors[id];

		allDeformers.push_back(jt);
		indices.push_back(ids[id]);
		jt->deformerId = ids[id];
	}

	for(unsigned int id = 0; id < ids.GetCount(); id++)
	{
		lookup[ids[id]] = id;
		escena->defIds[allDeformers[id]->nodeId] = ids[id];
	}

	// Establishes the parent relation
	vector<joint*> roots;
	for(unsigned int rel = 0; rel < relations.GetCount()-1; rel = rel+2)
	{
		LONG father = relations[rel];
		LONG child = relations[rel+1];

		if(father < 0)
		{
			roots.push_back(allDeformers[lookup[child]]);
			allDeformers[lookup[child]]->father = NULL;
		}
		else
		{
			allDeformers[lookup[father]]->childs.push_back(allDeformers[lookup[child]]);
			allDeformers[lookup[child]]->father = allDeformers[lookup[father]];
		}
	}

	// Build all the structure needed to work with these skeletons.
	vector<joint*> auxJoints;
	for(unsigned int i = 0; i< roots.size(); i++)
	{
		skeleton* skt = new skeleton(escena->getNewId());
		skt->root = roots[i];
		auxJoints.push_back(roots[i]);
		while(auxJoints.size() > 0)
		{
			joint* jtaux = auxJoints.back();
			auxJoints.pop_back();

			skt->joints.push_back(jtaux);
			for(unsigned int jtchild = 0; jtchild< jtaux->childs.size(); jtchild++)
			{
				auxJoints.push_back(jtaux->childs[jtchild]);
			}
		}

		// Asignamos las referencias para ir más rápido.
		for(unsigned int jtSkt = 0; jtSkt< skt->joints.size(); jtSkt++)
		{
			skt->jointRef[skt->joints[jtSkt]->nodeId] = skt->joints[jtSkt];
		}

		escena->skeletons.push_back(skt);
	}

	// We save reference to every joint using a global deformer id
	for(int i = 0; i< escena->skeletons.size();i++)
	{
		for(int j = 0; j< ((skeleton*)escena->skeletons[i])->joints.size(); j++)
		{
			joint* jt = ((skeleton*)escena->skeletons[i])->joints[j];
			escena->deformerRef[jt->deformerId] = jt;
		}
	}

	/*gridRenderer* grRender = ((gridRenderer*)escena->visualizers.back());

	grRender->bindedSkeletons.clear();
	for(unsigned int i = 0; i< escena->skeletons.size(); i++)
		grRender->bindedSkeletons.push_back((skeleton*)escena->skeletons[i]);*/
	
	return CStatus::OK;
}

ProgressBar staticBar;
bool barLoaded = true;

void setValueAtCurrentBar(int value)
{
	if(barLoaded)
	{
		staticBar.PutStep(value);
	}
}

void setTextAtCurrentBar(char* text)
{
	if(barLoaded)
	{
		staticBar.PutStatusText(text);
	}
}

SICALLBACK AirICENode_Evaluate( ICENodeContext& in_ctxt )
{
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
	switch( out_portID )
	{		
	case ID_OUT_outWeights :
			// Get the output port array ...			
			CDataArray2DFloat outData( in_ctxt);

			// Get the input data buffers for each port
			CDataArrayBool inRiggAnimFlag( in_ctxt, ID_IN_rigging_animation );
			CDataArrayBool inEvaluate(in_ctxt, ID_IN_rigging_evaluate);

			CICEGeometry inModel( in_ctxt, ID_IN_Model );
			CDataArray2DLong inNodeIds( in_ctxt, ID_IN_NodeIds );
			CDataArrayString inDataFileName( in_ctxt, ID_IN_embeddingFileName );
			CDataArray2DVector3f inNodePositions( in_ctxt, ID_IN_NodePositions );

			CDataArray2DFloat inNodeExpansionFactor( in_ctxt, ID_IN_expansionFactors );
			CDataArray2DFloat inNodePropagationFactor( in_ctxt, ID_IN_propagationFactors );
			CDataArrayFloat inGlobalSmooth( in_ctxt, ID_IN_globalSmoothing );
			CDataArrayFloat inSceneScale( in_ctxt, ID_IN_sceneScale );

			CDataArray2DLong inNodeParenting( in_ctxt, ID_IN_DefParentIds );

			// getting user data
			scene* escena = (scene*)(CValue::siPtrType)in_ctxt.GetUserData();

			CIndexSet indexSet( in_ctxt );
			CIndexSet::Iterator it = indexSet.Begin();

			ULONG inNodeSetSize = 1;
			inNodeSetSize = inNodePositions[it].GetCount();

			ULONG nPointCount = inModel.GetPointPositionCount();

			// A. If it's not active -> return dummy weights
			// Solo entraremos cuando no está inicializado y no queremos inicializarlo.
			if(!escena->initialized && inEvaluate[0] == escena->evaluate)
			{
				// 1. La escena queda a la espera de ser 
				// actualizada cuando se vuelva a activar.
				//escena->weightsUpdated = false;
				
				// 2. Devolvemos unos datos consistentes.
				// Al menos 1x1
				int iDefCount = 1;
				if(inNodeSetSize > 0)
					iDefCount = inNodeSetSize;

				int iPointCountAux = 1;
				if(nPointCount > 0)
					iPointCountAux = nPointCount;
	
				CDataArray2DFloat::Accessor outAccessor = outData.Resize( it, iPointCountAux * iDefCount);
				for(int ptId = 0; ptId < iPointCountAux; ptId++)
				{
					for(ULONG DefId = 0; DefId< (ULONG)iDefCount; DefId++)
					{
						outAccessor[ptId*iDefCount+DefId] = (float)(1.0/iDefCount);
					}
				}

				Application().LogMessage(CString(L"No evaluation - Air disabled"));
				Application().LogMessage(CString(L"Points :" + CString(iPointCountAux) + L"Deformers :" + CString(iDefCount)));

				// Acaba
				break;
			}


			Modelo* m = NULL; // = (Modelo*)escena->models.back();

			// B. If the model is not loaded -> load it from disc using in model.
			// Done only one time.
			if(!escena->initialized && !escena->modelLoaded)
			{
				Application().LogMessage(CString(L"Loading & processing the model..."));
				m = new Modelo(escena->getNewId());
				escena->models.push_back(m);

				LoadICEModel(inModel, m, escena);

				// Construimos tantos grafos como partes tiene el modelo
				BuildSurfaceGraphs(*m, m->bindings);
			}
			else
			{
				m = (Modelo*)escena->models.back();
			}

			// C. If the embedding is not loaded -> load from disc.
			//    If the grid is not loaded and there is a disc file -> load from disc.
			/*
			if(!escena->initialized && !escena->embeddingLoaded && escena->modelLoaded)
			{
				LoadDataFromDiscICE(escena, inDataFileName[0]);
			}
			*/

			// Si no se solicita actualizacion no hacemos nada.
			if(inRiggAnimFlag[0] || inEvaluate[0] != escena->evaluate)
			{

				Application app;

				UIToolkit kit = app.GetUIToolkit();
				ProgressBar bar = kit.GetProgressBar();

				bar.PutMaximum( 100 );
				bar.PutStep( 1 );
				bar.PutVisible( true );
				bar.PutStatusText( L"Getting skeleton updates." );

				staticBar = bar.GetRef();
				barLoaded = true;

				// Getting handlers to process data
				CDataArray2DLong::Accessor relations = inNodeParenting[0];
				CDataArray2DLong::Accessor ids = inNodeIds[0];
				CDataArray2DVector3f::Accessor defPositions = inNodePositions[0];
				CDataArray2DFloat::Accessor expansionFactors = inNodeExpansionFactor[0];
				CDataArray2DFloat::Accessor smoothingFactors = inNodePropagationFactor[0];

				escena->setGlobalSmoothness(inGlobalSmooth[0]);

				if(ids.GetCount() > 0 && relations.GetCount() > 0)
				{
					if(!escena->initialized)
						CreateSkeletonFromParentingRelations(ids, defPositions, relations /*, expansionFactors, smoothingFactors*/, escena);
					
					UpdateSkeletonParameters(ids, expansionFactors, smoothingFactors, escena);
				}

				bar.PutValue(20);
				bar.PutStatusText( L"Initializing the grid." );

				float gridResolution = 6;
				float sceneScale = inSceneScale[0];

				// Only one time ever
				if(!escena->initialized)
				{
					Application app;
					Project proj = app.GetActiveProject();
					CString sProjPath = proj.GetPath();

					CString sProjName = proj.GetName();

					char bindingFileName[150];
					char bindingFileNameComplete[150];
					sprintf(bindingFileName, "%s/bind_%s", sProjPath.GetAsciiString(), sProjName.GetAsciiString());
					sprintf(bindingFileNameComplete, "%s.bin", bindingFileName);

					m->sPath =  string(sProjPath.GetAsciiString());
					m->sName =  string(sProjName.GetAsciiString());

					bool ascii = false;

					// A. Intentamos cargarlo
					ifstream myfile;
					myfile.open (bindingFileNameComplete, ios::in |ios::binary);
					bool loaded = false;
					if (myfile.is_open())
					{
						// En el caso de existir simplemente tenemos que cargar las distancias.
						loaded = LoadEmbeddings(*m, bindingFileNameComplete);
					}

					//B. En el caso de que no se haya cargado o haya incongruencias con lo real, lo recomputamos.
					if(!loaded)
					{
						bool usePatches = false;
						bool success = ComputeEmbeddingWithBD(*m, usePatches);
						if(!success)
						{
							printf("[ERROR - computeProcess] No se ha conseguido computar el embedding\n");
							fflush(0);
							return false;
						}
						else SaveEmbeddings(*m, bindingFileName, ascii);
					}

					//
					for(int i = 0; i< escena->skeletons.size(); i++)
					{
						float minValue = GetMinSegmentLenght(getMinSkeletonSize((skeleton*)escena->skeletons[i]),0);
						((skeleton*)escena->skeletons[i])->minSegmentLength = minValue;

						for(int bind = 0; bind< m->bindings.size(); bind++)
							m->bindings[bind]->bindedSkeletons.push_back((skeleton*)escena->skeletons[i]);
					}

					for(int i = 0; i< m->bindings.size(); i++)
					{
						m->bindings[i]->weightsCutThreshold = escena->weightsThreshold;
					}


					// Grid Building
					//m->grid = new grid3d();

					// Se podría poner como parametros opcionales a pasar.
					//m->grid->fPrintText = setTextAtCurrentBar;
					//m->grid->fPrintProcessStatus = setValueAtCurrentBar;
					//m->grid->loadedFunctions = true;

					//BindSkeletons(escena, m->grid);

					// Voxelization
					//printf("Voxelization: only one time.\n"); fflush(0);
					//Voxelize(escena, m, gridResolution, sceneScale);
					escena->initialized = true;
				}
				else
				{
					//m->grid->fPrintText = setTextAtCurrentBar;
					//m->grid->fPrintProcessStatus = setValueAtCurrentBar;
					//m->grid->loadedFunctions = true;
				}

				bar.PutValue(30);
				bar.PutStatusText( L"computing skinning." );

				for(int bd = 0; bd < m->bindings.size(); bd++)
					m->bindings[bd]->smoothingPasses = sceneScale;

				ComputeSkining(*m);
				escena->evaluate = inEvaluate[0];

				bar.PutValue(100);
				bar.PutStatusText( L"End computation." );

				//reportResults(m);

				//m->grid->loadedFunctions = false;
				bar.PutVisible( false );
				barLoaded = false;
				escena->weightsUpdated = true;
			}

			CDoubleArray vertPos;
			inModel.GetPointPositions(vertPos);
			//gridRenderer* grRend = (gridRenderer*)escena->visualizers.back();
			CDataArray2DFloat::Accessor outAccessor = outData.Resize( it, nPointCount * inNodeSetSize);

			
			for (ULONG nPointID=0; nPointID < nPointCount; nPointID++)
			{
				//if(escena->weightsUpdated)
				//	bar.PutValue(90+(int)(((float)nPointID/(float)nPointCount)*10.0));

				Point3d ptPos(vertPos[nPointID*3], vertPos[nPointID*3+1], vertPos[nPointID*3+2]);

				// Reset Output array
				for(ULONG j = 0; j< inNodeSetSize; j++)
				{
					outAccessor[nPointID*inNodeSetSize+j] = 0.0;
				}

				//Point3i pt = grid->cellId(ptPos);
				//cell3d* cell = grid->cells[pt.X()][pt.Y()][pt.Z()];

				//if(!cell->data)
				//	printf("Este punto no tiene asignado ningún dato... curioso...\n");

				if(escena->weightsUpdated /*&& cell->data*/)
				{				
					float sum = 0;
					// Set Only the corresponding influences
					
					// de entrada cogeremos el primer binding
					if(!m || m->bindings.size() <= 0) continue;

					for(unsigned int w = 0; w< m->bindings[0]->pointData[nPointID].influences.size(); w++)
					{
						// >> Obtenemos el valor de influencia.
						float auxWeight =  m->bindings[0]->pointData[nPointID].influences[w].weightValue;

						sum += auxWeight;
						int idDeformer = m->bindings[0]->pointData[nPointID].influences[w].label;
							
						// >> Se pueden ordenar los valores de dos maneras diferentes:

						// A. por cada punto cada unos de los deformadores
						ULONG idx =  nPointID*inNodeSetSize + escena->defIds[idDeformer];
							
						// Por cada deformador todos los puntos.
						// B. ULONG idx =  defIds[idDeformer]*nPointCount+nPointID;
							
						// Guardamos el valor en el vector de salida.
						outAccessor[idx] =  auxWeight;
					}
					//if(sum != 1)
					//{
					//	int algoPasa = 1;
					//}
				}
				else
				{
					int iDefCount = inNodeSetSize;
					if(iDefCount == 0)
						iDefCount = 1;
					for(ULONG j = 0; j< inNodeSetSize; j++)
					{
						outAccessor[nPointID*inNodeSetSize+j] = (float)(1.0/iDefCount);
					}
				}
			}

			if(inRiggAnimFlag[0])
			{
				/*
				// updating info data structure
				//sceneUpdatingFlags* updatingInfo = new sceneUpdatingFlags();

				//escena->setGlobalSmoothness(inGlobalSmooth[0]);

				
				if(escena->inConnexionsTemp.firstTime)
				{
					updatingInfo->updateDefNodes = true;
					updatingInfo->updateSkinningFlag = true;
					escena->inConnexionsTemp.globalScale = inSceneScale[0];
					escena->inConnexionsTemp.globalSmooth = inGlobalSmooth[0];

					//Check changes in position
					for(unsigned int id = 0; id < ids.GetCount(); id++)
					{
						defInfo def;
						Point3d defPt(defPositions[id].GetX(), defPositions[id].GetY(), defPositions[id].GetZ());
						updatingInfo->defNodesToUpdate.push_back(id);

						def.position = defPt;
						def.smooth = smoothingFactors[id];
						def.expansion = expansionFactors[id];
					
						escena->inConnexionsTemp.deformers.push_back(def);
					}

					escena->inConnexionsTemp.firstTime = false;
				}
				else
				{
					//Check changes in sceneScale
					float temp = escena->inConnexionsTemp.globalScale;
					float inTemp = inSceneScale[0];
					if(escena->inConnexionsTemp.globalScale != inSceneScale[0])
					{
						escena->setSceneScale(inSceneScale[0]);
						updatingInfo->updateDefNodes = true;
						updatingInfo->updateSkinningFlag = true;
						escena->inConnexionsTemp.globalScale = inSceneScale[0];
					}

					temp = escena->inConnexionsTemp.globalSmooth;
					inTemp = inGlobalSmooth[0];
					//Check changes in globalSmooth
					if(escena->inConnexionsTemp.globalSmooth != inGlobalSmooth[0])
					{
						updatingInfo->updateDefNodes = true;
						updatingInfo->updateSkinningFlag = true;
						escena->setGlobalSmoothness(inGlobalSmooth[0]);
						escena->inConnexionsTemp.globalSmooth = inGlobalSmooth[0];
					}

					//Check changes in position
					for(unsigned int id = 0; id < ids.GetCount(); id++)
					{
						//bool updateDefNodes = false;
						//vector<int> defNodesToUpdate;
						Point3d defPt(defPositions[id].GetX(), defPositions[id].GetY(), defPositions[id].GetZ());
						if(escena->inConnexionsTemp.deformers[id].position != defPt)
						{
							updatingInfo->updateDefNodes = true;
							updatingInfo->defNodesToUpdate.push_back(id);
						}

						if(escena->inConnexionsTemp.deformers[id].smooth != smoothingFactors[id])
							updatingInfo->updateSkinningFlag = true;

						if(escena->inConnexionsTemp.deformers[id].expansion != expansionFactors[id])
							updatingInfo->updateSkinningFlag = true;
					}
				}
				

				// If there is no updating needed we abort process

				//if(!updatingInfo->updateDefNodes && !updatingInfo->updateSkinningFlag)
				//	escena->weightsUpdated = true;

				// Haremos los calculos solo si toca actualizar y estamos en modo animación.
				
				//if((!escena->weightsUpdated || updatingInfo->updateDefNodes || updatingInfo->updateSkinningFlag) && inRiggAnimFlag[0])

				if((inRiggAnimFlag[0] && !initialization)
				{
					Application app;

					UIToolkit kit = app.GetUIToolkit();
					ProgressBar bar = kit.GetProgressBar();

					bar.PutMaximum( 100 );
					bar.PutStep( 1 );
					bar.PutVisible( true );
					bar.PutStatusText( L"Loading model." );

					map<int, int> defIds;

					bar.PutValue(30);
					bar.PutStatusText( L"Loading data from disc." );
					// D. Loading the embedding and the grid.
					// Done only one time.

					bar.PutStatusText( L"Geting deformer info and relations." );
					if(ids.GetCount() > 0 && relations.GetCount() > 0)
					{
						CreateSkeletonFromParentingRelations(ids, defPositions, relations, expansionFactors, smoothingFactors, escena);
					}

					bar.PutValue(45);
					bar.PutStatusText( L"Computing air weights." );

					// Condiciones para no calcular nada
					if(!escena->embeddingLoaded || !escena->modelLoaded)
						break;



					// De momento solo actualizamos si no hay grid
					if(!initialization)
					{
						printf("Voxelization: only one time.\n"); fflush(0);
						Voxelize(escena, m, gridResolution, sceneScale);
					}

					grid3d& grid = *(m->grid);

					if(escena->visualizers.size() > 0)
					{
						gridRenderer* grRend = (gridRenderer*)escena->visualizers[0];
						ComputeSkining(m, grid);
						escena->weightsUpdated = true;
					}
					if(escena->weightsUpdated)
					{
						bar.PutValue(90);
						bar.PutStatusText( L"Saving data." );
					}
				}
				*/

				
			}
			
		break;
	};

	return CStatus::OK;
}


SICALLBACK AirICENode_BeginEvaluate( ICENodeContext& in_ctxt )
{
	// Control para multithread y operaciones comunes.

	// If the scene is not loaded, we can try to do it here.

	/*
	// Example to demonstrate how to allocate a thread safe user data buffer.
	CValue userData = in_ctxt.GetUserData( );

	// Create a CSampleData object for each thread
	ULONG nThreadCount = in_ctxt.GetEvaluationThreadCount( );

	std::vector<CSampleData>* pPerThreadData = NULL;
	if ( userData.IsEmpty() )
	{
		pPerThreadData = new std::vector<CSampleData>;
		in_ctxt.PutUserData( (CValue::siPtrType)pPerThreadData );
	}
	else
	{
		pPerThreadData = (std::vector<CSampleData>*)(CValue::siPtrType)in_ctxt.GetUserData( );
	}

	if ( pPerThreadData && pPerThreadData->size() < nThreadCount )
	{
		// Extend buffer if needed
		for(ULONG i = (ULONG)pPerThreadData->size(); i < nThreadCount; i++)
		{
			pPerThreadData->push_back( CSampleData() );
		}
	}
	*/
	return CStatus::OK;
}



SICALLBACK AirICENode_EndEvaluate( ICENodeContext& in_ctxt )
{

	/*
	// Release memory allocated in BeginEvaluate
	CValue userData = in_ctxt.GetUserData( );
	if ( userData.IsEmpty() )
	{
		return CStatus::OK;
	}

	std::vector<CSampleData>* pPerThreadData = (std::vector<CSampleData>*)(CValue::siPtrType)in_ctxt.GetUserData( );
	delete pPerThreadData;

	// Clear user data"] ); 
	in_ctxt.PutUserData( CValue() );
	*/
	
	
	return CStatus::OK;
}



SICALLBACK AirICENode_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	scene* snc = new scene();
	ctxt.PutUserData( CValue::siPtrType(snc) );

	Application().LogMessage(L"AIR_ICE_NODE: The memory for the scene has been gathered.",siInfoMsg);
	return CStatus::OK;
}

SICALLBACK AirICENode_Term( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	scene* snc = (scene*)(void*)ctxt.GetUserData();
	::free( snc ) ;

	// just to be sure:
	ctxt.PutUserData(XSI::CValue((void*)NULL)) ;

//	scene* escena = (scene*)(CValue::siPtrType)ctxt.GetUserData();
//	delete escena;

	Application().LogMessage(L"AIR_ICE_NODE: Memory has been released.",siInfoMsg);
	return CStatus::OK;
}

