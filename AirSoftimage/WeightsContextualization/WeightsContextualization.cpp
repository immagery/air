// Weights Contextualization Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Mon Jan 21 15:16:14 UTC+0100 2013 by Chus
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_inWeights = 1,
	ID_IN_pointPositions = 2,
	ID_IN_defIdsCount = 4,
	ID_G_100 = 100,
	ID_G_101 = 101,
	ID_G_102 = 102,
	ID_OUT_weightsPerPoint = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterWeightsContextualization( XSI::PluginRegistrar& in_reg );

using namespace XSI; 

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Jesus Rodriguez Nieto");
	in_reg.PutName(L"Weights Contextualization Plugin");
	in_reg.PutVersion(1,0);

	RegisterWeightsContextualization( in_reg );

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

CStatus RegisterWeightsContextualization( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"WeightsContextualization",L"Weights Contextualization");

	CStatus st;
	st = nodeDef.PutColor(154,188,102);
	st.AssertSucceeded( ) ;


	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_101);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddPortGroup(ID_G_102);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_inWeights,ID_G_100,siICENodeDataFloat,siICENodeStructureArray,siICENodeContextSingleton,L"inWeights",L"inWeights",0,CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_pointPositions,ID_G_101,siICENodeDataVector3,siICENodeStructureSingle,siICENodeContextComponent0D,L"pointPositions",L"pointPositions",MATH::CVector3f(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_defIdsCount,ID_G_102,siICENodeDataLong,siICENodeStructureSingle,siICENodeContextSingleton,L"defIdsCount",L"defIdsCount",0,CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(ID_OUT_weightsPerPoint,siICENodeDataFloat,siICENodeStructureArray,siICENodeContextComponent0D,L"weightsPerPoint",L"weightsPerPoint",ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Air nodes");

	return CStatus::OK;
}


SICALLBACK WeightsContextualization_Evaluate( ICENodeContext& in_ctxt )
{
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
  
	switch( out_portID )
	{		
		case ID_OUT_weightsPerPoint :
		{
			// Get the output port array ...			
			CDataArray2DFloat outData( in_ctxt );
			
 			// Get the input data buffers for each port
			CDataArray2DFloat inWeightsData( in_ctxt, ID_IN_inWeights );
			CDataArrayVector3f pointPositionsData( in_ctxt, ID_IN_pointPositions );
			CDataArrayLong defIdsCountData( in_ctxt, ID_IN_defIdsCount );

			ULONG pointCount = pointPositionsData.GetCount();

 			// We need a CIndexSet to iterate over the data 		
			CIndexSet indexSet( in_ctxt );
			for(CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{
				CDataArray2DFloat::Accessor outAccessor = outData.Resize( it, defIdsCountData[it]);
				CDataArray2DFloat::Accessor inWeightsSubArray = inWeightsData[it];

				for(int i = 0; i< defIdsCountData[it]; i++)
				{
					outAccessor[i] = inWeightsSubArray[it*pointCount+i];
				}
			}
		}
		break;
		
		// Other output ports...
	};
	
	return CStatus::OK;
}

